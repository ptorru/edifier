/*
MIT License

Copyright (c) 2021 Pedro M. Torruella N.
*/

use serde::{Serialize};
use serde::ser::{Serializer, SerializeSeq};

#[derive(Debug)]
pub struct PortRef {
    pub name: String,
    pub instanceref: String
}
impl Serialize for PortRef {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        let mut seq = serializer.serialize_seq(Some(3))?;
        seq.serialize_element(&"portref".to_string())?;
        seq.serialize_element(&self.name)?;
        if  !self.instanceref.is_empty() {
            let instref = (&"instanceref".to_string(), &self.instanceref);
            seq.serialize_element(&instref)?;
        }
        
        seq.end()
    }        
}

#[derive(Debug)]
pub struct PortList (pub Vec<PortRef>);

impl PortList {
    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }
}

impl Serialize for PortList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut seq = serializer.serialize_seq(Some(self.0.len() + 1))?;
        seq.serialize_element(&"joined".to_string())?;
        for portref in self.0.iter() {
            seq.serialize_element(&portref)?;
        }
        seq.end()
    }
}

#[derive(Debug)]
// TODO: add support for rename
pub struct ContentNet {
    pub name: String,
    pub portlist: PortList,
}
impl Serialize for ContentNet {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        let mut seq = serializer.serialize_seq(Some(3))?;
        seq.serialize_element(&"net".to_string())?;
        seq.serialize_element(&self.name)?;

        if  !self.portlist.is_empty() {
            seq.serialize_element(&self.portlist)?;
        }
        seq.end()
    }        
}

#[derive(Debug)]
// TODO: add support for rename
pub struct ContentInstance {
    pub name: String,
    pub viewref: String,
    pub cellref: String,
    pub libraryref: String,
}
impl Serialize for ContentInstance {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        let mut seq = serializer.serialize_seq(Some(3))?;
        let all = ("viewref", &self.viewref, 
                      ("cellref", &self.cellref, 
                      ("libraryref", &self.libraryref)));

        seq.serialize_element(&"instance".to_string())?;
        seq.serialize_element(&self.name)?;
        seq.serialize_element(&all)?;
        seq.end()
    }        
}

#[derive(Debug)]
pub enum ContentElement {
    Instance,
    Net,
}

impl Serialize for ContentElement {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        let mut seq = serializer.serialize_seq(Some(2))?;
        seq.serialize_element(&"direction".to_string())?;
        match self {
            ContentElement::Instance  => {seq.serialize_element(&"instance".to_string())?;},
            ContentElement::Net => {seq.serialize_element(&"net".to_string())?;}
        }
        seq.end()
    }
}

#[derive(Debug)]
pub struct CellContent {
    pub contents: Vec<ContentElement>,
}

impl Serialize for CellContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        if  !self.contents.is_empty() {
            let mut seq = serializer.serialize_seq(Some(2))?;
            seq.serialize_element(&"contents".to_string())?;
            // Here we have to iterate manually, to skip one level
            // of parentheses generated by the default vec serializer
            for element in self.contents.iter() {
                seq.serialize_element(&element)?;
            }
            seq.end()
        } else {
            serializer.serialize_none()
        }
    }        
}
            



#[derive(Debug)]
pub enum PortDirection {
    Input,
    Output,
}

impl Serialize for PortDirection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        let mut seq = serializer.serialize_seq(Some(2))?;
        seq.serialize_element(&"direction".to_string())?;
        match self {
            PortDirection::Input  => {seq.serialize_element(&"INPUT".to_string())?;},
            PortDirection::Output => {seq.serialize_element(&"OUTPUT".to_string())?;}
        }
        seq.end()
    }
}

#[derive(Debug)]
pub enum PortElements {
    Direction(PortDirection),
    //Array(PortArray)
}

impl Serialize for PortElements {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        match self {
            PortElements::Direction(dir) => dir.serialize(serializer)
        }
    }        
}


#[derive(Debug)]
pub struct InterfacePort {
    pub name: String,
    pub element: PortElements,
}

impl Serialize for InterfacePort {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        let mut seq = serializer.serialize_seq(Some(3))?;
        seq.serialize_element(&"port".to_string())?;
        seq.serialize_element(&self.name)?;
        seq.serialize_element(&self.element)?;
        seq.end()
    }        
}


#[derive(Debug)]
pub struct CellInterface(pub Vec<InterfacePort>);

impl CellInterface {
    pub fn is_empty(&self) -> bool{
        self.0.is_empty()
    }

    pub fn len(&self) -> usize {
        self.0.len()
    }

    // TODO: probably implement the iter function too?
}

impl Serialize for CellInterface {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        let ports_num = self.len();
        if  ports_num != 0 {
            let mut seq = serializer.serialize_seq(Some(1 + ports_num))?;
            seq.serialize_element(&"interface".to_string())?;
            // Here we have to iterate manually, to skip one level
            // of parentheses generated by the default vec serializer
            for port in self.0.iter() {
                seq.serialize_element(&port)?;
            }
            seq.end()
        } else {
            serializer.serialize_none()
        }
    }        
}

#[derive(Debug)]
pub struct CellView {
    pub name: String,
    pub interface: CellInterface,
    pub content: CellContent,
}

impl Serialize for CellView {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        let mut seq = serializer.serialize_seq(Some(4))?;
        let viewtype = ("viewtype", "NETLIST");

        seq.serialize_element("view")?;
        seq.serialize_element(&self.name)?;
        seq.serialize_element(&viewtype)?;

        seq.serialize_element(&self.interface)?;


        seq.serialize_element(&self.content)?;

        seq.end()
    }        
}

#[derive(Debug)]
pub struct Cell {
    pub name: String,
    pub views: Vec<CellView>,
}

impl Serialize for Cell {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        let mut seq = serializer.serialize_seq(Some(4))?;
        let celltype = ("celltype", "GENERIC");

        seq.serialize_element("cell")?;
        seq.serialize_element(&self.name)?;
        seq.serialize_element(&celltype)?;
        if  !self.views.is_empty() {
            seq.serialize_element(&self.views)?;
        }
        seq.end()
    }        
}

#[derive (Debug)]
pub struct Library {
        pub name: String,
        pub elements: Vec<Cell>,
}

impl Serialize for Library {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        let mut seq = serializer.serialize_seq(Some(3))?;

        seq.serialize_element("Library")?;
        seq.serialize_element(&self.name)?;
        if  !self.elements.is_empty() {
            seq.serialize_element(&self.elements)?;
        }
        seq.end()
    }        
}


#[derive(Debug)]
pub enum EdifElements {
    Library(Library),
    //Design(String)
}

impl Serialize for EdifElements {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {    
        match self {
            EdifElements::Library(lib) => lib.serialize(serializer)
        }
    }        
}


#[derive(Debug)]
pub struct Edif {
    pub name: String,
    pub elements: Vec<EdifElements>,
}


impl Serialize for Edif {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        // 1) Need to count the number of fields we will have on the
        //    main branch.
        //
        // 3 is the number of fields in the struct.
        let mut seq = serializer.serialize_seq(Some(6))?;
        let version = ("edifversion", "2", "0", "0");
        let level = ("edifLevel", 0);
        let kword = ("keywordmap", ("keywordlevel", 0));

        seq.serialize_element("edif")?;
        seq.serialize_element(&self.name)?;
        seq.serialize_element(&version)?;
        seq.serialize_element(&level)?;
        seq.serialize_element(&kword)?;

        if  !self.elements.is_empty() {
            seq.serialize_element(&self.elements)?;
        }


        seq.end()
    }
}